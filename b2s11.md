# Taller Grupal 1: Programación Funcional Reactiva

**Semana:** 11  
**Asignatura:** Programación Funcional y Reactiva  

---

### Objetivos:
- Crear un `case class` en Scala para modelar datos específicos de un archivo CSV.
- Manipular colecciones de datos y realizar operaciones de filtrado y cálculos estadísticos.
- Aplicar fórmulas matemáticas (varianza) mediante el uso de funciones de agregación y procesamiento funcional.

> [!IMPORTANT]
> Resolver el siguiente problema en grupos según proyecto integrador (**solo estudiantes presentes en el aula**). El archivo a utilizar es: **`pi_movies_small.csv`**.

---

### Parte 1: Definición de case class y lectura de archivo

1. **Definición de la estructura:** Cree una `case class` llamada `Movie` que permita leer las siguientes columnas del archivo CSV: `adult`, `revenue`, `popularity`, `runtime` y `vote_average`.
2. **Tipado de datos:** Configure los atributos de la siguiente manera para asegurar un procesamiento correcto:
    - `adult`: `Boolean`
    - `revenue`: `Double`
    - `popularity`: `Double`
    - `runtime`: `Double`
    - `vote_average`: `Double`
3. **Implementación de lectura:** Utilizando la librería `fs2-data-csv` y el stack de `Cats Effect`, realice la lectura del archivo y convierta los datos en una lista de objetos de tipo `Movie`. Recuerde que el delimitador del archivo es punto y coma (`;`).

> **Entregable:** Código de la `case class` y el bloque de código funcional que realiza la lectura y carga de los datos.

---
```scala
package segundoBimestre.semana9.semana11




import cats.effect.{IO, IOApp}
import fs2.text
import fs2.io.file.{Files, Path}
import fs2.data.csv.*
import fs2.data.csv.generic.semiauto.*


case class Movie1(
                  adult: String,
                  revenue: Double,
                  popularity: Double,
                  runtime: Double,
                  vote_average: Double
                )


given CsvRowDecoder[Movie1, String] =
deriveCsvRowDecoder[Movie1]


object LeerMovie1s extends IOApp.Simple:

  
  val filePath =
    Path("src/main/resources/data/pi_movies_small (1).csv")

  
  val run: IO[Unit] =
    Files[IO]
      .readAll(filePath)                 
      .through(text.utf8.decode)         
      .through(decodeUsingHeaders[Movie1](';')) 
      .compile
      .toList                           
      .flatMap { Movie1s =>
        IO.println(s"Total de películas cargadas: ${Movie1s.length}")
      }
}
```
<img width="748" height="244" alt="image" src="https://github.com/user-attachments/assets/d03927c9-7593-425e-aaa8-fa75ece1eae0" />


### Parte 2: Análisis de datos

Utilizando la lista de objetos obtenida en la parte anterior, implemente la lógica para resolver los siguientes requerimientos:

1. **Filtrado por ingresos:** Obtenga y muestre una lista (o el conteo) de todas las películas cuyo `revenue` (ingresos) sea estrictamente mayor al promedio de ingresos de todo el conjunto de datos.
2. **Cálculo de la varianza:** Calcule la varianza de las calificaciones (`vote_average`) aplicando la siguiente fórmula:

$$
\sigma^2 = \frac{\sum_{i=1}^{n} (x_i - \overline{x})^2}{n}
$$

Donde:
- $x_i$: es el **vote_average** de cada película.
- $\overline{x}$: es el promedio de los **vote_average**.
- $n$: es el número total de películas procesadas.

> **Entregable:** Bloques de código donde se apliquen las funciones de orden superior (`filter`, `map`, `sum`) para resolver ambos puntos y capturas de pantalla de los resultados impresos en la consola.
````scala
import cats.effect.{IO, IOApp}
import fs2.text
import fs2.io.file.{Files, Path}
import fs2.data.csv.*
import fs2.data.csv.generic.semiauto.*

//Case class con nombres iguales a los headers del CSV
case class Movie(
                  adult: Boolean,
                  revenue: Double,
                  popularity: Double,
                  runtime: Double,
                  vote_average: Double
                )

//Derivación automática del decoder (Estilo Scala 3)
given CsvRowDecoder[Movie, String] = deriveCsvRowDecoder[Movie]

object Estadisticos:
  //Adaptado para listas de Double
  def suma(datos: List[Double]): Double = datos.sum

  def promedio(datos: List[Double]): Double =
    if datos.isEmpty then 0.0
    else datos.sum / datos.length

  def conteo[A](datos: List[A]): Int = datos.length

  // Fórmula: sum((xi - x_promedio)^2) / n
  def varianza(datos: List[Double]): Double =
    if datos.isEmpty then 0.0
    else
      val media = promedio(datos)
      val sumCuadrados = datos.map(x => Math.pow(x - media, 2)).sum
      sumCuadrados / datos.length


// Objeto principal - Lectura y procesamiento
object AnalisisPeliculas extends IOApp.Simple:

  val filePath = Path("src/main/resources/data/pi_movies_small.csv")

  val run: IO[Unit] =
    val lecturaCSV: IO[List[Movie]] = Files[IO]
      .readAll(filePath)
      .through(text.utf8.decode)
      .through(decodeUsingHeaders[Movie](';')) //delimitador
      .compile
      .toList

    lecturaCSV.flatMap { movies =>
      // Extracción de columnas de interés
      val colRevenue: List[Double] = movies.map(_.revenue)
      val colVoteAverage: List[Double] = movies.map(_.vote_average)

      //Obtener promedio de ingresos
      val promedioIngresos = Estadisticos.promedio(colRevenue)

      //Filtrar películas con ingresos mayores al promedio
      val peliculasTaquilleras = movies.filter(_.revenue > promedioIngresos)

      (
        IO.println("=" * 60) >>
          IO.println("       ESTADÍSTICAS - REVENUE (INGRESOS)") >>
          IO.println("=" * 60) >>
          IO.println(s"  Total películas:      ${Estadisticos.conteo(movies)}") >>
          IO.println(s"  Suma total ingresos:  $$${Estadisticos.suma(colRevenue)}") >>
          IO.println(s"  Promedio ingresos:    $$%.2f".format(promedioIngresos)) >>
          IO.println(s"  Películas > Promedio: ${Estadisticos.conteo(peliculasTaquilleras)}") >>
          IO.println("") >>
          IO.println("=" * 60) >>
          IO.println("       ESTADÍSTICAS - VOTE_AVERAGE (CALIFICACIONES)") >>
          IO.println("=" * 60) >>
          IO.println(s"  Promedio votos:       %.4f".format(Estadisticos.promedio(colVoteAverage))) >>
          //función varianza creada en el objeto Estadisticos
          IO.println(s"  Varianza calculada:   %.4f".format(Estadisticos.varianza(colVoteAverage))) >>
          IO.println("=" * 60)
        )
    }.handleErrorWith { error =>
      IO.println(s"Error al leer el archivo: ${error.getMessage}")
    }

````
![WhatsApp Image 2025-12-19 at 08 33 54](https://github.com/user-attachments/assets/06e81928-47c1-4fe7-9b9e-e3a92a40eda9)
![WhatsApp Image 2025-12-19 at 08 33 54 (1)](https://github.com/user-attachments/assets/fb9a9727-b9a3-4109-955f-58ad529e2c23)
![WhatsApp Image 2025-12-19 at 08 33 54 (2)](https://github.com/user-attachments/assets/be17a03f-c67c-4bd0-9cd7-bbae3c0bb717)



---

### ✅ Calificación:

Una vez que termine debe presentar su trabajo a su docente.

- **10 puntos:** si presenta en el horario de prácticas y experimentación.
- **7 puntos:** si presenta en el horario de tutoría.

**La hora máxima de presentación será las 08h30.**

